--- Partial Berkeley Algorithm, featuring 1-server, multi-client model
--- with timeout and message delays, but poll only once

--- With multiple clients, a server will need to know the rtt of all
--- its clients to compute each client's offset

--- To ensure resend of request after 100 ms., server would need a 
--- dynamic number of timers. This makes the system more complex & interesting

load real-time-maude.maude

(tomod DATA-TYPES is

  --- Need a data type for lists of Oid's to store the list of clients:

  sort OidSet .
  subsort Oid < OidSet .

  op none : -> OidSet [ctor] .
  op _;_ : OidSet OidSet -> OidSet [ctor assoc comm id: none] .

  --- Need a datatype to store each client's time value on server for two purposes: 
  --- 1. for each "pending" rtt request we need a timer value
  --- 2. to store the rtt value for computation
  --- Obviously, these two data types are the same, but to make
  --- the spec more readable, we still give them different names ...

  sorts Timer Timers .
  subsort Timer < Timers .

  op timer : Oid Time -> Timer [ctor] .
  op noTimer : -> Timers [ctor] .
  op _;_ : Timers Timers -> Timers [ctor assoc comm id: noTimer] .

  var T : Time .
  var OID : Oid .
  var OSet : OidSet .

  op initializeTimers : OidSet Time -> Timers .
  eq initializeTimers(none, T) = noTimer .
  eq initializeTimers(OID ; OSet, R) = timer(OID, T) ; initializeTimers(OSet, T) .

  --- Finally, we need to store pairs of oid's and rtt values.
  --- This data type is isomorphic with "ClientTimers":

  sort RttValue RttValues .
  subsort RttValue < RttValues .
  op rttValue : Oid Time -> RttValue [ctor] .
  op noValue : -> RttValues [ctor] .
  op _;_ : RttValues RttValues -> RttValues [ctor assoc comm id: noValue] .
endtom)




(tomod MSGS is
  including DATA-TYPES .
  protecting NAT-TIME-DOMAIN .     --- needed for the value 0

  --- The messages should now be equipped with a receiver and sender
  --- field so that objects know who are sending stuff ...
  --- We follow Maude's "convention" of having the receiver of the message
  --- as the first argument ...
  msgs rtt? rttAck : Oid Oid Time -> Msg .
  msg findRtt : Oid -> Msg .

  sort DlyMsg .
  subsorts Msg < DlyMsg < NEMsgConfiguration .
  --- The dly operators on messages:
  op dly : Msg Time -> DlyMsg [ctor right id: 0] .

  --- A multiDlyRtt? message to a group of receivers is dissolved
  --- into a set of single delayed messages to each receiver ...

  msg multiDlyRtt? : OidSet Oid Time Time -> Configuration .
  --- usage: multiDlyRtt?(receiver_group, sender, clock_value, min_trans_delay)

  vars O O' : Oid .  var OS : OidSet .  vars R R' : Time .

  eq multiDlyRtt?(none, O, R, R') = none .
  eq multiDlyRtt?(O ; OS, O', R, R') = 
        dly(rtt?(O, O', R), R') multiDlyRtt?(OS, O', R, R') .
endtom)


(tomod MANY-RTTS is
  including MSGS .
  including NAT-TIME-DOMAIN-WITH-INF .  --- Inf OK for mte and delta

  ops MAX-RTT MIN-DELAY : -> Time .   

  class Node | clock : Time, 
               nbs : OidSet, 
               resendTimers : Timers, 
               rttValues : RttValues .


  vars O O' : Oid .
  var OS : OidSet .
  vars R R' R'' : Time .
  var TIMERS : Timers . 
  var RTTVALS : RttValues .

  --- Start: send a rtt? message, with approrpiate min delay, to all neighbors:
  rl [findRttOfAllNbrs] : 
     findRtt(O)
     < O : Node | nbs : OS, clock : R, resendTimers : TIMERS >
       =>
         < O : Node | resendTimers : TIMERS ; initializeTimers(OS, MAX-RTT) >
         multiDlyRtt?(OS, O, R, MIN-DELAY) .

  --- Reception of a rtt? message is done by ack'ing with the same time stamp:
  rl [ackRequest] :
     rtt?(O, O', R)  < O : Node | >  
      =>  
        < O : Node | >  dly(rttAck(O', O, R), MIN-DELAY) .

  --- Reception of an ack within time MAX-RTT:
  crl [recAckOK] :
      rttAck(O, O', R)
      < O : Node | clock : R', rttValues : RTTVALS, 
                   resendTimers : TIMERS ; timer(O', R'') >
       =>
         < O : Node | rttValues : RTTVALS ; rttValue(O', R' monus R),
                      resendTimers : TIMERS > 
      if R' monus R < MAX-RTT .

  --- Reception of an too old message which is just discarded:
  crl [recAckTooOld] :
      rttAck(O, O', R)  < O : Node | clock : R' >  =>  < O : Node | > 
      if R' monus R >= MAX-RTT .

  --- Resend a rtt? request to O' when when the timer for O' expires:
  rl [resendRttRequest] :
     < O : Node | clock : R, resendTimers : TIMERS ; timer(O', 0) >
      =>
        < O : Node | resendTimers : TIMERS ; timer(O', MAX-RTT) >
        dly(rtt?(O', O, R), MIN-DELAY) .

  --- Now, the tick rule must
  ---   increase all clocks
  ---   decrease all timers
  ---   decrease the remaining dly-time for dly-messages
  ---   with the elapse of time
  --- and must not advance time beyond the first point in time 
  ---   a timer could expire:

  crl [tick] : {C:Configuration}  =>  
                  {delta(C:Configuration, R)} in time R 
               if R <= mte(C:Configuration) [nonexec] .
     
  --- Delta models the effect of time elapse on a system, and mte 
  --- finds the "next" sometime some instantaneous rule must be applied:

  op delta : Configuration Time -> Configuration [frozen (1)] .
  eq delta(none, R) = none .
  eq delta(NeC:NEConfiguration NeC':NEConfiguration, R) =
       delta(NeC:NEConfiguration, R) delta(NeC':NEConfiguration, R) .
  eq delta(< O : Node | clock : R, resendTimers : TIMERS >, R') =
        < O : Node | clock : R + R',  resendTimers : delta(TIMERS, R') > .
  eq delta(dly(M:Msg, R), R') = dly(M:Msg, R monus R') .

  op delta : Timers Time -> Timers .
  eq delta(noTimer, R) = noTimer .
  eq delta(timer(O, R) ; TIMERS, R') = 
       timer(O, R monus R') ; delta(TIMERS, R') .

  op mte : Configuration -> TimeInf [frozen (1)] .
  eq mte(none) = INF .
  eq mte(NeC:NEConfiguration NeC':NEConfiguration) =
       min(mte(NeC:NEConfiguration), mte(NeC':NEConfiguration)) .
  eq mte(< O : Node | resendTimers : TIMERS >) = mte(TIMERS) .
  eq mte(DM:DlyMsg) = INF .       --- no stopping necessary when message ripe!

  op mte : Timers -> TimeInf .
  eq mte(noTimer) = INF .
  eq mte(timer(O, R) ; TIMERS) = min(R, mte(TIMERS)) .
endtom)


--- The following module defines an initial state with four nodes
--- and defines some values for MAX-RTT and MIN-DELAY:

(tomod TEST-MANY-RTTS is including MANY-RTTS .
  ops n1 n2 n3 n4 : -> Oid [ctor] .  --- Names of nodes:

  eq MAX-RTT = 4 .    eq MIN-DELAY = 1 .

  op initState : -> GlobalSystem .
  eq initState =
      {findRtt(n2)
       findRtt(n4)
       < n1 : Node | clock : 0,
                     nbs : n2 ; n3 ; n4,
                     resendTimers : noTimer,
                     rttValues : noValue >
       < n2 : Node | clock : 0,
                     nbs : n1,
                     resendTimers : noTimer,
                     rttValues : noValue >
       < n3 : Node | clock : 0,
                     nbs : n1 ; n4,
                     resendTimers : noTimer,
                     rttValues : noValue >
       < n4 : Node | clock : 0,
                     nbs : n1 ; n3,
                     resendTimers : noTimer,
                     rttValues : noValue >} .
endtom)

--- (tfrew initState in time < 100 .)

--- search for bad state, where a rtt value outside of
--- desired range is found:


*** search for BAD rtt values:
***(tsearch [1] initState =>* 
               {C:Configuration 
                < O:Oid : Node | rttValues : RTTVALS:RttValues ; 
                                             rttValue(O':Oid, RTTVAL:Time) >}
                  such that RTTVAL:Time < (2 * MIN-DELAY)  
                            or RTTVAL:Time >= MAX-RTT
                     in time <= 7 .)


--- The following module defines some propositions for use in temporal logic
--- model checking as explained in the manual:

(tomod MODEL-CHECK-MANY-RTTS is
  including TIMED-MODEL-CHECKER .
  protecting MANY-RTTS .

  --- Any rtt value greater than MAX-RTT?
  op badRttValue : -> Prop [ctor] .

  var REST : Configuration .
  vars O O' : Oid .
  vars R R' R'' : Time .
  var RTT-VALS : RttValues .

  ceq {REST  < O : Node | rttValues : rttValue(O', R) ; RTT-VALS >}
        |=
      badRttValue = true if  R >= MAX-RTT or R < 2 * MIN-DELAY . 

  ops rttFound currentMsgExchange : Oid Oid -> Prop [ctor] .
  
  eq {REST  < O : Node | rttValues : rttValue(O', R) ; RTT-VALS >}
        |=
     rttFound(O, O') = true .

  ceq {REST  rtt?(O', O, R)} in time R'
        |=
      currentMsgExchange(O, O') = true  if R + MAX-RTT > R' .

  ceq {REST  rttAck(O, O', R)} in time R'
        |=
      currentMsgExchange(O, O') = true  if R + MAX-RTT > R' .


  op findMsgExists : Oid -> Prop [ctor] .

  eq {REST findRtt(O)}
        |=
     findMsgExists(O) = true .

  --- Superfluous message present somewhere in the system?
  op superfluousMsg : -> Prop [ctor] .

  ceq {< O : Node | rttValues : rttValue(O', R) ; RTT-VALS >   
       rtt?(O', O, R')
       REST}  in time R'' 
        |= 
      superfluousMsg  = true   if R' + MAX-RTT > R'' .

  ceq {< O : Node | rttValues : rttValue(O', R) ; RTT-VALS >   
       rttAck(O, O', R')
       REST}  in time R'' 
        |= 
      superfluousMsg  = true   if R' + MAX-RTT > R'' .


  op rttValueIs : Oid Oid Time -> Prop [ctor] .

  ceq {REST  < O : Node | rttValues : rttValue(O', R) ; RTT-VALS >}
        |=
      rttValueIs(O,O', R)  = true   if  not O' in RTT-VALS .

  op _in_ : Oid RttValues -> Bool .
  eq O in noValue = false .
  eq O in rttValue(O', R) ; RTT-VALS = (O == O') or O in RTT-VALS .
endtom)



--- Also take the initial state into account when model checking:

(tomod MODEL-CHECK-TEST-MANY-RTTS is
  protecting TEST-MANY-RTTS .
  including MODEL-CHECK-MANY-RTTS .
endtom)


--- No too large rtt values are ever stored. Due to the high degree of 
--- nondeterminism, it can only be checked up to time 9 on my machine.
--- The constant MAX-RTT should be redefined to 4 before 
--- executing the following spec:

---(mc initState |=t [] ~ badRttValue in time <= 9 .)

--- if there is no findRtt msg for n4, then either there is a recorded
--- rtt value for the pair n4, n3, or there is a current message exchange
--- going on to find such an rtt value:

***(mc initState |=t
      (~ findMsgExists(n4)) => 
         [] (rttFound(n4, n3) \/ currentMsgExchange(n4, n3))
      in time <= 9 .)

--- there is no superfluous message in the system:

***(mc initState |=t [] ~ superfluousMsg in time <= 9 .)

--- stability of rtt values: once the rtt from n4 to n3 is found to be 
--- 2, then it will remain 2:

***(mc initState |=t rttValueIs(n4, n3, 2) => [] rttValueIs(n4, n3, 2)
      in time <= 9 .)